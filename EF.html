<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Syntax Tree Visualizer</title>
  <style>
    body { font-family: Arial, sans-serif; background: #0f1724; color: #e6eef8; margin: 0; padding: 20px; }
    h1 { font-size: 22px; }
    input, button { padding: 8px; border-radius: 6px; border: none; margin: 5px; }
    input { width: 280px; }
    button { background: #7c3aed; color: white; cursor: pointer; }
    button:hover { background: #9f67fa; }
    #err { color: #ffb4b4; margin-top: 10px; }
    #canvas-wrap { background: #081226; border-radius: 8px; padding: 12px; margin-top: 20px; overflow: auto; height: 600px; }
    svg { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <h1>Syntax Tree Visualizer (AST)</h1>
  <p>Enter an arithmetic expression and click <b>Parse & Draw</b>:</p>
  <input id="expr" type="text" value="a * b + c - 7" />
  <button id="parse">Parse & Draw</button>
  <button id="clear">Clear</button>
  <div id="err"></div>
  <div id="canvas-wrap">
    <svg id="svgroot" viewBox="0 0 1200 800" preserveAspectRatio="xMinYMin meet"></svg>
  </div>
  <script>
    // --- Lexer & Parser ---
    function tokenize(input) {
      const tokens = [];
      const re = /\s*([A-Za-z_][A-Za-z0-9_]*|\d*\.\d+|\d+|\^|\+|\-|\*|\/|\(|\))/g;
      let m, idx = 0;
      while (idx < input.length) {
        re.lastIndex = idx;
        m = re.exec(input);
        if (!m) { throw new Error('Unexpected token near: ' + input.slice(idx).trim().split(/\s+/)[0]); }
        tokens.push(m[1]);
        idx = re.lastIndex;
      }
      tokens.push('<EOF>');
      return tokens;
    }

    function parseExpression(input) {
      const tokens = tokenize(input);
      let i = 0;
      function peek() { return tokens[i]; }
      function consume() { return tokens[i++]; }

      function primary() {
        const t = peek();
        if (t === '(') { consume(); const node = expr(); if (peek() !== ')') throw new Error('Missing )'); consume(); return node; }
        if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(t) || /^\d*\.\d+$/.test(t) || /^\d+$/.test(t)) {
          consume(); return { type: 'leaf', value: t };
        }
        throw new Error('Unexpected token: ' + t);
      }

      function unary() {
        const t = peek();
        if (t === '+' || t === '-') {
          consume(); const node = unary(); return { type: 'unary', op: t, child: node };
        }
        return primary();
      }

      function pow() {
        let left = unary();
        if (peek() === '^') {
          const op = consume(); const right = pow();
          return { type: 'binary', op, left, right };
        }
        return left;
      }

      function mul() {
        let left = pow();
        while (peek() === '*' || peek() === '/') {
          const op = consume(); const right = pow();
          left = { type: 'binary', op, left, right };
        }
        return left;
      }

      function add() {
        let left = mul();
        while (peek() === '+' || peek() === '-') {
          const op = consume(); const right = mul();
          left = { type: 'binary', op, left, right };
        }
        return left;
      }

      function expr() { return add(); }

      const tree = expr();
      if (peek() !== '<EOF>') throw new Error('Unexpected extra token: ' + peek());
      return tree;
    }

    // --- Layout & Render ---
    function layoutTree(root) {
      let leafX = 0;
      function dfs(node) {
        if (node.type === 'leaf') {
          node._x = leafX; node._y = 0; leafX += 120; return;
        }
        if (node.type === 'unary') {
          dfs(node.child);
          node._x = node.child._x; node._y = node.child._y - 120; return;
        }
        if (node.type === 'binary') {
          dfs(node.left); dfs(node.right);
          node._x = (node.left._x + node.right._x) / 2; node._y = Math.min(node.left._y, node.right._y) - 120; return;
        }
      }
      dfs(root);

      let minX = Infinity, minY = Infinity;
      function findMin(n) {
        if (!n) return;
        minX = Math.min(minX, n._x); minY = Math.min(minY, n._y);
        if (n.type === 'unary') findMin(n.child);
        if (n.type === 'binary') { findMin(n.left); findMin(n.right); }
      }
      findMin(root);
      const offsetX = 60 - minX; const offsetY = 80 - minY;
      function apply(n) {
        if (!n) return;
        n._x += offsetX; n._y += offsetY;
        if (n.type === 'unary') apply(n.child);
        if (n.type === 'binary') { apply(n.left); apply(n.right); }
      }
      apply(root);
      return root;
    }

    function renderSVG(root) {
      const svg = document.getElementById('svgroot');
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      if (!root) return;
      const nodes = [];
      function collect(n) {
        if (!n) return;
        nodes.push(n);
        if (n.type === 'unary') collect(n.child);
        if (n.type === 'binary') { collect(n.left); collect(n.right); }
      }
      collect(root);

      function drawEdge(x1, y1, x2, y2) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        path.setAttribute('x1', x1); path.setAttribute('y1', y1);
        path.setAttribute('x2', x2); path.setAttribute('y2', y2);
        path.setAttribute('stroke', '#94a3b8'); path.setAttribute('stroke-width', '2');
        svg.appendChild(path);
      }

      function renderNode(n) {
        const x = n._x; const y = n._y;
        if (n.type === 'binary') {
          drawEdge(x, y + 18, n.left._x, n.left._y + 20);
          drawEdge(x, y + 18, n.right._x, n.right._y + 20);
        }
        if (n.type === 'unary') {
          drawEdge(x, y + 18, n.child._x, n.child._y + 20);
        }
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${x - 40}, ${y - 18})`);

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('width', '80'); rect.setAttribute('height', '36'); rect.setAttribute('rx', '8');
        rect.setAttribute('fill', 'rgba(124,58,237,0.2)'); rect.setAttribute('stroke', '#7c3aed');
        g.appendChild(rect);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '40'); text.setAttribute('y', '22'); text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', 'white'); text.textContent = (n.type === 'leaf' ? n.value : n.op);
        g.appendChild(text);

        svg.appendChild(g);
      }

      nodes.forEach(renderNode);
    }

    // --- UI ---
    document.getElementById('parse').addEventListener('click', () => {
      const s = document.getElementById('expr').value.trim();
      try {
        document.getElementById('err').textContent = '';
        const tree = parseExpression(s);
        layoutTree(tree);
        renderSVG(tree);
      } catch (e) {
        document.getElementById('err').textContent = e.message;
      }
    });

    document.getElementById('clear').addEventListener('click', () => {
      document.getElementById('expr').value = '';
      document.getElementById('svgroot').innerHTML = '';
      document.getElementById('err').textContent = '';
    });

    window.addEventListener('load', () => { document.getElementById('parse').click(); });
  </script>
</body>
</html>